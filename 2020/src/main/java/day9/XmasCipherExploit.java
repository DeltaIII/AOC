package day9;

import com.google.common.collect.Iterables;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;

public class XmasCipherExploit {

    private final int cipherPreambleLength;

    public XmasCipherExploit(final int cipherPreambleLength) {
        this.cipherPreambleLength = cipherPreambleLength;
    }

    public long getEncryptionWeakness(final List<Long> encryptedData) {
        final CipherResponse attemptedDecode =
            new XmasCipher(cipherPreambleLength).decode(encryptedData);
        if (attemptedDecode.isValid() || !attemptedDecode.getInvalidNumber().isPresent()) {
            throw new IllegalArgumentException("No weakness found in data!");
        }

        final Long exploitKey = attemptedDecode.getInvalidNumber().get();
        final List<Long> exploitData = getExploitData(exploitKey, encryptedData);

        return getExploitWeakness(exploitData);
    }

    private long getExploitWeakness(final List<Long> exploitData) {
        exploitData.sort(Long::compareTo);
        return exploitData.get(0) + Iterables.getLast(exploitData);
    }

    private List<Long> getExploitData(final Long exploitKey, final List<Long> encryptedData) {
        long currentSum = 0L;
        Map<Long, Integer> previousSumIndices = new HashMap<>();

        for (int index = 0; index < encryptedData.size(); index++) {
            currentSum += encryptedData.get(index);

            // Does removing required value hits a previously seen sum
            long requiredPreviousSum = currentSum - exploitKey;
            if (previousSumIndices.containsKey(requiredPreviousSum)){
                // Correct set starts 1 after the stored sum. End has + 1 due to slicing.
                return encryptedData.subList(previousSumIndices.get(requiredPreviousSum) + 1, index + 1);
            }

            previousSumIndices.put(currentSum, index);
        }
        throw new IllegalArgumentException("No answer found");
    }
}
